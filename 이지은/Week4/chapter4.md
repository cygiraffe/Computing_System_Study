# 기계어

숫자: 4
태그: 하드웨어

***형태는 기능을 따른다***

기계어 : 기계 수준의 명령어를 코딩할 수 있도록 미리 정의된 언어 

대상 하드웨어 플랫폼에서 직접적으로 명령을 실행하고, 하드웨어를 완전히 제어하는 것이 목표 

직접적이고 효율적으로 명령을 실행하는 조건을 만족하는 것이 목표

프로그래밍 도구인 동시에 하드웨어 플랫폼 구성 요소

### 하드웨어 요소

1. 메모리 
    - 컴퓨터에서 데이터와 명령어를 저장하는 하드웨어 장치
    - 고유한 주소를 가지며 위치 또는 메모리 레지스터로도 참조될 수 있는 셀들의 연속적 배열
2. 프로세서 
    - 특정한 기초 연산들을 수행하는 장치 (중앙 처리 장치 또는 CPU라 불린다)
    - 산술 및 논리 연산, 메모리 접근 연산, 제어 연산 포함
    - 선택한 레지스터나 메모리 위치에서 입력을 갖고 와서, 선택된 레지스터나 메모리 위치에 출력 기록 (게이트 논리, ALU, 레지스터 모음으로 구성)
3. 레지스터
    - 프로세서와 메모리는 개별적이고 독립적인 두 개의 칩으로 구현되며, 두 칩 사이에 데이터를 옮기는 건 상대적으로 느린 작업
    - 프로세스 칩 내부에 위치. 프로세서가 데이터와 명령어를 빠르게 조작할 수 있도록 로컬 고속 메모리 역할을 한다.
    - 종류
        - 데이터 레지스터 : 데이터 저장
        - 주소 레지스터 : 주소로 해석되는 값들을 저장
        - 주소 레지스터에 특정 값 *n* 을 설정한 경우, 주소가 *n*인 메모리 위치가 클록 주기 내에 선택되도록 구성

### 언어

기계어 프로그램은 ***2진***과 ***기호*** 의 두 가지 버전으로 동일하게 작성 가능하다. 

**어셈블리어** : 기호 기계어 

**어셈블러** : 2진 코드로 번역하는 프로그램 

### 명령어

***산술 및 논리 연산***

모든 기계어는 기본적 산술 연산과 논리 연산을 위한 명령어를 지원

이런 기호 명령어를 컴퓨터에서 실행하려면 2진 코드로 번역해야 한다. 

이 번역은 어셈블러라는 프로그램이 진행

***메모리 접근***

기계어에서 수행되는 작업들을 특정 메모리 위치에 접근해서 조작 

예 : 메모리 위치 17에 값 1을 설정하려고 한다면, `load A, 17` 과 `load M, 1` 이라는 명령어 지시

M은 관례상 A가 선택한 메모리 레지스터를 의미 

***흐름 제어***

명령어 하나씩 순차적으로 실행되지만, 다음 명령어 대신에 특정 위치로 점프하는 경우도 있다. 

기계어는 이러한 분기 동작을 위해 조건 및 무조건 goto 분기 명령어와 

goto의 목적지를 설정하는 레이블 선언문을 몇 가지 지원 

***기호*** 

재배치 가능 코드 : 물리적 주소를 쓰지 않는 저수준 코드 

기호 참조는 단순한 꾸밈 요소로서가 아니라, 코드가 불필요하게 물리적 메모리 주소와 얽히지 않도록 만들어주는 용도로 쓰인다. 

### 핵 기계어

**폰 노이만 구조** 라는 일반적인 컴퓨터 설계에 따른다. 

1. 메모리 
    - 데이터 메모리
    - 명령어 메모리 (ROM)
2. 레지스터 
    - 3개의 16비트 레지스터 (데이터, 주소, 선택된 데이터) 를 조작하도록 설계가 되어 있다.
    - D = M / M = D +1 / D = 0 / D = M -1 같은 식으로 쓴다.
    - 이 중, 주소 레지스터는 많은 역할을 하는데, 데이터 레지스터 뿐만 아니라 메모리 및 명령어 메모리 주소 지정에도 활용된다.
3. 주소 지정 
    - @xxx ⇒ A 레지스터에 값 xxx를 설정한다는 뜻
        - 주소가 xxx인 레지스터를 **‘선택된 메모리 레지스터 M’**으로 만든다는 뜻
        - 주소가 xxx인 ROM 레지스터의 값을 **‘선택된 명령어’** 로 만든다는 뜻
    - 주소를 지정한다는 것은 다른 두 가지 후속 작업을 준비하는 것과 같다.
4. 분기 
    - 무조건 분기 명령어 `@29` → `0;JMP`
        - A 레지스터가 지정하는 주소의 명령어로 이동하여 실행하라는 의미
        - ROM에는 주소 0부터 실행하려는 프로그램의 명령어들이 있다고 가정하기 때문에 ROM[29]을 실행할 명령어로 삼게 된다.
    - 조건부 분기 명령어 `@52` → `D:JEQ`
        - D를 평가(evaluate)한 후에 값이 0과 같으면 A가 지정한 주소에 저장된 명령어로 점프하여 실행
5. 변수 
    - @xxx 에서  xxx는 상수나 기호 모두 가능
        - 상수로 지정이 되어있다면, 바로 상수로 진행
        - 명령어가 xxx가 513 같은 특정 값에 바인딩이 되어있다면 513으로 설정이 된다.

---

- 예제
    
    메모리 접근 예제 
    
    ```sql
    // D = 17    
    @17          -- @17: 주소 17을 지정합니다.
    D = A        -- D 레지스터에 A 레지스터의 값을 저장(A는 17)
    
    // RAM[100] = 17   
    @17 
    D=A
    @100         -- 주소 100을 지정
    M=D          -- 메모리 주소 100에 D 레지스터의 값을 저장
    
    // RAM[100] = RAM[200] 
    @200         -- 주소 200을 지정합니다.
    D=M          -- D 레지스터에 메모리 주소 200의 값을 저장
    @100         -- 주소 100을 다시 지정
    M=D          -- 메모리 주소 100에 D 레지스터의 값을 저장
    ```
    
    분기 예제 
    
    ```sql
    // GOTO 29 
    @29 
    0;JMP 
    
    // IF D > 0 GOTO 63
    @63
    D;JGT
    ```
    
    ---
    
    변수 사용 예제 
    
    ```sql
    // X = -1
    @X
    M = -1
    
    // COUNT = COUNT - 1
    @COUNT 
    M = M - 1
    
    // SUM = SUM + X 
    @SUM 
    D = M
    @X 
    D = D + M   -- X를 지정하는 이유가... 
    @SUM 
    M = D
    ```
    

명령어는 주소 명령어 (@로 시작하는) 와 계산 명령어 (그 외의 모든 명령어) 로 이루어진다. —

### 구문 규칙과 파일 형식

- 2진 코드 파일
    - `hack` 확장자를 갖는 텍스트 파일에 저장이 된다.
    - 각 라인에 하나의 2진 명령어를 나타내며, 16개의 0과 1 문자로 된 문자열을 효시한다.
    - 기계어 프로그램이 컴퓨터의 명령어 메모리에 로드가 될 때, 파일의 n번째 라인의 2진 코드는 명령어 메모리 주소의 n에 저장이 된다.
    - 0에서 시작한다.
- 어셈블리어 파일
    - `asm` 확장자를 갖는 텍스트 파일에 저장이 된다.
    - 각 라인은 *A-명령어, C-명령어, 레이블 선언, 주석* 중 하나로 설정이 된다.
    - 레이블 선언은 같은 형식의 텍스트 라인이지만, 별다른 2진 코드를 생성하지 않으므로 ***의사 명령어*** 라고도 불린다.
- 상수와 기호
- 주석
- 공백
- 대소문자 규칙